210119 화

- String.length()
- Array.length
- Arrays.toString(배열)

- int intArray[] = {-3, -1, 1, 3, 5}; // Array Constant
	- 한번 할당된 값을 변경할 수 없다.
	- Array Constant는 선언과 동시에 초기화해야한다.
	- Array 요소 중 값을 할당받지 않은 요소는 default value 값을 가진다.
		원래 local variable은 default value 값을 가지지 않는다.
	- Array Constants는 동일 변수에 새로운 배열 할당 불가
- System.arraycopy(시작obj, 시작pos, 도착obj, 도착pos, length)
- 다차원 배열이라 하더라도, 각 배열마다 길이가 모두 같을 필요는 없다. 어차피 각자 referencing함

- java.util.Scanner
	.hasNex()
	.next()
	.hasNextXXX()
	.nextXXX()
	.nextLine()
	.nextChar() X ← .next().charAt(0)

-----------------------------------

210121 수

- Switch~Case (정수 / 문자 / 문자열)
 - Switch~Case (byte / short / int / char / String)
 - long은 wrong
 - defalt는 맨 뒤에 넣는 것을 권장하지만 앞에 넣어도 오류는 나지 않음
 
- 배열선언과 데이터 초기화하는 부분을 따로 작성할 수 없음!!!!!!!
  int [] su; // 배열선언
         su = {1,2,3,4,5}; // 배열초기화   (X)
		 su = new int[]{1, 2, 3, 4, 5}; // 배열 초기화 가능!! (O)
  
  int []su = {1,2,3,4,5}; // 선언과 초기화 (O)
  
- 2차원 배열에서 열 크기는 가변적이다.
	int [ ][ ] nums = new int [ 3 ] [  ];
	nums[0]=new int[2]; 
	nums[1]=new int[3]; 
	nums[2]=new int[1]; 

- 자바는 GC가 메모리 관리를 해주지만
  IO, DataBase (공유하는 자원) 관련 객체는 반환을 해줘야 한다.=> close()

- 배열 주소 복사
	// 원본 : su배열, 타겟 su3 배열
	int[] su3 = su; // new int[su.length]; // su 배열의 메모리 주소를 복사!!
		// su, su3 배열은 같은 메모리 주소를 참조!!!!!!!!!!
	
	su3[2] = 33; // su[2]도 변경됨!!

- Arrays.sort(배열)

- random 생성은 Math.random보다 이게 더 효율적이다.
	Random generator = new Random(); // 객체 생성
	int randomNum = generator.nextInt(45) + 1;


---------------------------------------

210121 목

- Scanner()
 1. 공백으로 구분
	nextInt() int
	next() String
 2. 엔터로 구분
	nextLine() String
 두 방법 혼용해서 쓰면 오류날 가능성이 높다.

- JVM의 3가지 메모리 영역 : Class Area (Method Area) for Class, Static, Method
							Heap for Objects
							Stack for Call
							
- Java는 new 연산자로 Memory Allocation을 수행하지만 Deallocation은 JVM이 알아서 처리한다.
	JVM은 Heap에 만들어진 객체 중에서 더 이상 참조되지 않은 것들을 대상으로 적절한 시점에 Garbage Collecion 작업을 수행한다.
	
- String s1 = "Hello"; 
  객체 상수( 일종의 리터럴 ), String Constant Pool 
	
- String Builder
	StringBuilder sb = new StringBuilder("");
	sb.append(s1).append(", ").append(s2);
 	sb.setLength(0); 
	// 시작 위치를 앞으로 잡아서 객체를 새로 만들지 않고 재사용함
	
- toString() 메소드는 객체 만들 때 자동적으로 만들어진다. (Object로부터 상속됨)
  재정의하여 사용
  System.out.println(객체); // -> 객체.toString() 자동 호출
  
- pass by value -> 메소드로 파라미터 전달 시 메인 메소드의 변수 값 변화 x
  pass by reference -> 변화
  
- test case data를 txt파일로 프로젝트 폴더 바로 밑에 넣어놓고
  입력 시에 System.int (키보드로 입력) 대신 System.setIn
  
- 자바에서 break는 반복문과 조건문 중 switch에서만 사용된다.
			continue는 반복문에서만 사용된다.
			
----------------------------------------

210122 금

- 자바 빈즈 (JavaBeans) - 서로 관련성 있는 속성들의 묶음
	==> VO (Value Obeject), DTO (Data Transfer Object)란 용어로도 사용한다.
	==> 사용 용도 : UI에 입력된 데이터를 묶어주기, DB 테이블의 레코드 (row) 한 개를 표현
	
    기본규칙)
	- 속성들은 private 선언
  	- public getter, setter 메소드 정의
  	- public 생성자 정의
  	
  	==> 유연성을 갖는다.
  		- 반드시 속성에 매핑되는 getter, setter가 있어야 되는 것은 아님
  		- 속성이 아닌 것에 대한 getter, setter를 정의해도 됨
  		- 생성자는 private일 수도 있음
		
- Alt + Shift + S, 혹은 우클릭 -> Source 자동완성
	Getter and Setter
	Constructors using Feilds
- ctrl + space + enter -> 기본 생성자 생성!!!!!

- toString() 메소드 : 현 클래스의 상태 (정보, 데이터)를 표현하는 메소드

- 클래스 내에서 멤버의 작성 순서) 1) 필드, 2) 생성자, 3) 메소드
- ctrl + shift + f ==> 포함 관계에 따른 들여쓰기 기능 (indent)

- 부모 데이터가 필요한 위치에 자식 데이터가 위치/사용되는 것이 가능하다
  자식 클래스는 부모 클래스로 형변환이 가능하다.
  Parent p2 = new Child();  	// pc2 = c;  ==> 실행 됨 (Compile, Run Ok)
  
- 클래스 안에는 생성자가 최소 하나는 정의되어야 하는데
  하나도 없으면 기본 생성자가 자동으로 정의된다.
  그러나, 하나라도 있으면 컴파일러가 관여x => 있는 생성자의 파라미터 따라야 함
  
- 생성자 간 호출 가능 => this() 문자열 받을 다른 생성자 호출
  this()가 생성자 맨 윗줄에 와야 함
  
  	Abc() { 
		this("strstrstr"); // 생성자 간 호출 가능 => this() 문자열 받을 다른 생성자 호출
		System.out.println("기본 생성자");
	}
	
	Abc(String str) { 
		System.out.println("오버로딩 생성자");
		this.str = str; // this 없으면 main 에서 값 안바뀜!!
	}
	
	Abc abc2 = new Abc(); // 기본 생성자
	System.out.println("STR = " + abc2.str); //	STR = strstrstr


- 싱글톤패턴

----------------------------------------

부모 클래스의 print()함수가 자식 클래스에서 오버라이딩/ 재정의 되어 있을 때 

  부자되세요 부->자 

## 1. `Parent p = new Child();` // O 
- 자식은 -> 부모로 형변환 가능 
 - 만들어지는 클래스 타입은 new 이후 오른쪽 -> 
 - 할당되는 참조 변수의 유형은 <- new 왼쪽 
 - Parent 객체 참조 변수에 담긴다. <- Child() 생성자로 Child 클래스가 만들어져  
 - memory 상에는 `Object - Parent - Child` 클래스들을 위한 공간들이 위에서부터 생기고 
   p 변수는 Parent의 주소를 참조한다!! 
 - 1) 따라서 p 변수는 Parent 공간에서 메소드들을 찾으며, Parent 공간에서 못찾으면 순차적으로 위로 간다. 
-> 부모 참조변수 p를 통해 자식 메소드 호출 불가능!! 
 - 2) 예외> `p.print();` // 자식 클래스에서 오버라이딩 한대로 출력됨!! 
   - 메모리 상에 Child 공간이 있기 때문임 

## 2. `Child c = new Child(); `
- 자식 클래스가 상속받은 메소드를 오버라이딩 했더라도. `super.print()` 형식으로 부모의 메소드 기능을 사용할 수 있다. 
Child c = new Child(); 
    -> 자식 참조 변수 c로 부모 메소드 호출 가능 -> `super` 

- 상속 예외!! 1) private 2) 부모의 생성자 

## 3. `Child c3 = (Child) p;`
- 형변환 
- 부모 참조변수 p로 자식 클래스를 참조하고 싶을 때!!! 
 - 메모리상 Parent 밑에 있는 Child 영역도 p 변수가 접근 가능해진다.
 
---------------------------------------------

210123
`printf()` 메소드는, 문자열 형식에 변수를 삽입하여 출력한다.

`%d` : 10진수(정수)
`%x` : 16진수
`%o` : 8진수
`%f` : 실수

1. 0진수(정수) `%d`
- 0으로 채워수 출력하기
 `%5d` -> 0으로 채워서 다섯 자리수로 만들기, 오른쪽 정렬
 `-%5d` -> 0으로 채워서 다섯 자리수로 만들기, 왼쪽 정렬
 
2. 16진수 `%x`
 - `%x` -> 16진수 소문자로 출력
 - `%X` -> 16진수 대문자로 출력

3. 8진수 `%o`

4. 실수 `%d`
 - `%.2f` -> 반올림하여 소수점 두자리수 까지 출력하기
 - `%5.1f` -> 정수 부분은 0으로 채워서 다섯자리 수까지, 실수부분은 반올림하여 소수 첫째자리수 까지 출력하기
			(정수부분이 다섯자리 수 넘어가면 정수 부분 전체가 출력된다.
	`System.out.printf("%5.3f", 12345667.3258); // 12345667.326`
	
------------------------------------------------	

String xNum = sc.next(); // 16진수 입력
int dNum = Integer.parseInt(xNum, 16); // 16진수 수가 10진수로 변환된다.

---------------------------------------------

210126 화
Arrays.copyOfRange(books, 0, size);

"java".contains("av") ==> true
"java".contains("xy") ==> false
